# This routine is shared by the 2D/3D glvolume fragment shaders. It
# figures out the colour to use for a specific voxel.
#
# Inputs
#
#   {{ texCoord }} - Fragment texture coordinates
#
#   {{ clipTexCoord }} - Clip image texture coordinates
#
#   {{ clipping }} - Vector containing clipping values - voxels with a
#      value below the low threshold (x), or above the high threshold (y) will
#      not be shown. The (z) component determines the clipping direction -
#      pass in -1 for the above behaviour, or +1 to invert this behaviour
#      (i.e. to clip values that are within the range). The (w) component is a
#      boolen flag which indicates whether the image texture is to be used as
#      the clip texture. Clipping values are assumed to be normalised to the
#      image texture value range.
#
#   {{ negCmap }} - Negative colour map control. The (x) component is a
#      boolean flag controlling whether the negative colour map is used. The
#      (y) component is the display range centre (the value above which the
#      regular colour map is used, and below which the negative colour map is
#      used), as a voxel value, normalised to the image texture value range.
#
#   {{ voxValXform }}  - Vector with x component defining a scale, and y
#      component defining an offset, with which image texture values can be
#      transformed into the range [0, 1], for use as a colour map texture
#      coordinate.

#   {{ imageTexture     }} - 3D texture containing the image
#   {{ clipTexture      }} - 3D texture containing clipping image
#   {{ colourTexture    }} - 1D texture containing colour map
#   {{ negColourTexture }} - 1D texture containing negative colour map
#
#
# Outputs:
#
#   {{ out_kill }} - X component is set to -1 if the fragment should be
#      killed (it was NaN or clipped), +1 otherwise.
#
#   {{ out_colour }} - Final colour to use for this fragment.
#
#
# Constants:
#
#   kill_fragments_early - If True, the fragment is killed if it is NaN
#      or clipped. Otherwise the fragment is not killed, but its status
#      is passed back via the out_kill output.
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#


TEMP _voxValue;
TEMP _clipValue;
TEMP _clipValueNoClip;
TEMP _useNegCmap;
TEMP _negVoxValue;
TEMP _negClipValue;
TEMP _voxClipLo;
TEMP _voxClipHi;
TEMP _posColour;
TEMP _negColour;


# look up image voxel value
# and clipping value from 3D
# image/clipping textures
TEX _voxValue.x,  {{ texCoord }},     {{ imageTexture }}, 3D;
TEX _clipValue.x, {{ clipTexCoord }}, {{ clipTexture  }}, 3D;

# Discard this fragment if the voxel
# value is nan - there is no nan test,
# or equality test, so we test whether
# (value >= value) || (value < value)
SGE {{ out_kill }}.y,   _voxValue.x,       _voxValue.x;
SLT {{ out_kill }}.z,   _voxValue.x,       _voxValue.x;
ADD {{ out_kill }}.x, {{ out_kill }}.y,  {{ out_kill }}.z;
SUB {{ out_kill }}.x, {{ out_kill }}.x,     0.5;

{% if kill_fragments_early %}
KIL {{ out_kill }}.x;
{% endif %}

# If the clipping texture coords
# are out of bounds, disable
# clipping (by clobbering the
# clip value with something that
# will cause no clipping to occur).

# clipValueNoClip contains clipLo + 0.5 * (clipHi - clipLo)
MOV _clipValueNoClip.x, {{ clipping }}.y;
SUB _clipValueNoClip.x,   _clipValueNoClip.x, {{ clipping }}.x;
MUL _clipValueNoClip.x,   _clipValueNoClip.x,    0.5;
ADD _clipValueNoClip.x,   _clipValueNoClip.x, {{ clipping }}.x;


# Clobber the clip value if necessary
{{
arb_call('texture_border.prog',
         texCoord='{{ clipTexCoord }}',
         origval='_clipValue',
         borderval='_clipValueNoClip',
         out_result='_clipValue')
}}

# If the image texture is the clip
# texture, overwrite the clip value
# we just looked up.
CMP _clipValue.x, {{ clipping }}.w, _clipValue.x, _voxValue.x;

# Figure out which colour map
# should be used for this fragment.
#
# We use the negative colour map ...
#
# if the voxel value is less than
# texZero (the display range centre),
SLT _useNegCmap.x, _voxValue.x, {{ negCmap }}.y;

# and the negative colour map is active.
# The useNegCmap vector will be negative
# if both of these conditions are true,
# positive otherwise.
MUL _useNegCmap.x, _useNegCmap.x, {{ negCmap }}.x;
SUB _useNegCmap.x, _useNegCmap.x, 0.5;
MUL _useNegCmap.x, _useNegCmap.x, -1;

# If using the negative colour map,
# we need to flip the voxel value about
# the display range centre.

# Calculate the inverted voxel value
ADD _negVoxValue.x, {{ negCmap }}.y,  {{ negCmap }}.y;
SUB _negVoxValue.x,   _negVoxValue.x,   _voxValue.x;

# And do the same for the clip value -
# this is necessary if the image texture
# is the clipping texture.
ADD _negClipValue.x, {{ negCmap }}.y,   {{ negCmap }}.y;
SUB _negClipValue.x,   _negClipValue.x,   _clipValue.x;

# If we're using the negative colour
# map, replace the original voxel
# value with the inverted one.
CMP _voxValue.x, _useNegCmap.x, _negVoxValue.x, _voxValue.x;

# And do the same to the clip value if
# the image texture is the clip texture.
CMP _negClipValue.x, _useNegCmap.x, _negClipValue.x, _clipValue.x;
CMP _clipValue.x, {{ clipping }}.w, _clipValue.x, _negClipValue.x;

# Test the low clipping range
SUB _voxClipLo.x, _clipValue.x, {{ clipping }}.x;

# And the high clipping range
SUB _voxClipHi.x, _clipValue.x, {{ clipping }}.y;

# Multiply the low/high results - after
# this, voxClipLo will be positive if
# the value is outside of the clipping
# range, or negative if the value is
# within the clipping range
MUL _voxClipLo.x, _voxClipLo.x, _voxClipHi.x;

# Multiply by the clipping.z setting -
# this will invert the sign if normal
# (as opposed to inverted) clipping is
# active.
MUL _voxClipLo.x, _voxClipLo.x, {{ clipping }}.z;

# We need to clip voxels if the value is
# less than or equal to the low clipping
# range, or greater than or equal to the
# high clipping range. This equates to
# testing whether voxClipLo is less than
# or equal to zero. Unfortunately the KIL
# instruction tests for less than zero.
# So these three instructions manipulate
# voxClipLo such that values which are
# less than or equal to 0 are set to -1.
MUL _voxClipLo.x, _voxClipLo.x, -1.0;
SGE _voxClipLo.x, _voxClipLo.x,  0.0;
MUL _voxClipLo.x, _voxClipLo.x, -1.0;

# If the voxel value is outside
# the clipping range (or inside,
# if clipping is inverted), don't
# draw it
MIN {{ out_kill }}.x, {{ out_kill }}.x, _voxClipLo.x;

{% if kill_fragments_early %}
KIL _voxClipLo.x;
{% endif %}

# Scale voxel value according
# to the current display range
MAD _voxValue, _voxValue, {{ voxValXform }}.x, {{ voxValXform }}.y;

# look up the appropriate colour
# in the 1D colour map texture
TEX _posColour, _voxValue.x, {{ colourTexture    }}, 1D;
TEX _negColour, _voxValue.x, {{ negColourTexture }}, 1D;

# useNegCmap is negative if the
# negative colour map should be
# used, positive otherwise.
CMP {{ out_colour }}, _useNegCmap.x, _negColour, _posColour;
