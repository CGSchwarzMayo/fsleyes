!!ARBfp1.0
#
# Fragment program used for rendering GLVector instances, where
# the vector orientation is represented by a combination of RGB colours.
#
# This fragment program does the following:
# 
#  - Retrieves the voxel coordinates corresponding to the fragment
# 
#  - Uses those voxel coordinates to look up the corresponding xyz
#    directions value in the 3D RGB image texture.
#
#  - Looks up the colours corresponding to those xyz directions.
#
#  - Modulates those colours by the modulation texture.
#
#  - Uses those voxel values to colour the fragment.
#
# Input parameters:
#
#   voxValXform - Transformation matrix which transforms the vector
#                 image voxel values from their texture value
#                 to the original data range.
#
#   cmapXform   - Transformation matrix which transforms the vector
#                 image voxel values from their data values
#                 to a value which can be used as texture coordinates
#                 for the colour map textures.
#
#   imageShape  - Image shape - number of voxels along the xyz
#                 dimensions in the image
#
#   clipping    - Clipping thresholds. The (x) component contains
#                 the low clipping threshold, and the (y) component
#                 contains the high threshold.
#
#   mod         - Modulation range. The (x) component contains
#                 the low modulation value, and the (y) component
#                 contains a scaling factor equal to 1 / (modHigh - modLow).
#
#   xColour     - Colour corresponding to the X vector direction.
#
#   yColour     - Colour corresponding to the Y vector direction.
#
#   zColour     - Colour corresponding to the Z vector direction.
#
#   colourXform - Scale/offset to be applied to the vector value before
#                 it is combined with the three colours, for brightness/
#                 contrast adjustment. The first component contains
#                 the scaling factor, and the second component contains
#                 the offset.
#
# Input textures:
#
#   vectorTexture   - 3D texture containing the vector data.
#   modulateTexture - 3D texture containing brightness modulation values.
#   clipTexture     - 3D texture containing clipping values.
#
# Input varyings:
# 
#   texCoord - Fragment texture coordinates
#   voxCoord - Fragment voxel coordinates 
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

TEMP  voxCoord;
TEMP  clipValue;
TEMP  modValue;
TEMP  voxValue;
TEMP  fragColour;
TEMP  clipResult;
PARAM voxValXform[4] = {{ param4_voxValXform }};
PARAM cmapXform[4]   = {{ param4_cmapXform   }};
PARAM imageShape     = {{ param_imageShape   }};
PARAM clipping       = {{ param_clipping     }};
PARAM mod            = {{ param_mod          }};
PARAM xColour        = {{ param_xColour      }};
PARAM yColour        = {{ param_yColour      }};
PARAM zColour        = {{ param_zColour      }};
PARAM colourXform    = {{ param_colourXform  }};

# retrieve the voxel coordinates 
MOV voxCoord, {{ varying_voxCoord }};

# Bail if the voxel coordinate
# is out of the image space
#pragma include test_in_bounds.prog

# look up vector, modulation, and clipping
# values from the three 3D textures.
TEX voxValue,  {{ varying_texCoord }}, {{ texture_vectorTexture   }}, 3D;
TEX modValue,  {{ varying_texCoord }}, {{ texture_modulateTexture }}, 3D;
TEX clipValue, {{ varying_texCoord }}, {{ texture_clipTexture     }}, 3D;

# If the clipping value is
# <= the low clipping range,
# or >= the high clipping
# range, kill the fragment.
SUB clipResult.x, clipValue.x, clipping.x;
SUB clipResult.y, clipping.y,  clipValue.x;

# Set the clipResults which are less than or
# equal to zero to negative 1. See comment
# about this in glvolume_frag.prog.
MUL clipResult, clipResult, -1.0;
SGE clipResult, clipResult,  0.0;
MUL clipResult, clipResult, -1.0;

KIL clipResult.x;
KIL clipResult.y;

# Transform vector values from their normalised 
# texture range to their original data range,
# and take the absolue value
MAD voxValue, voxValue, voxValXform[0].x, voxValXform[3].x;
ABS voxValue, voxValue;

# Cumulatively combine the rgb
# channels of those three colours
MAD fragColour, voxValue.x, xColour, fragColour;
MAD fragColour, voxValue.y, yColour, fragColour;
MAD fragColour, voxValue.z, zColour, fragColour;

# Copy the alpha value - we don't 
# want it to be modulated. Using
# voxValue as a temp variable
MOV voxValue.a, fragColour.a;

# Apply the bri/con scale and offset
MAD fragColour, fragColour, colourXform.x, colourXform.y;

# Scale the modulation value, and modulate the colour
ADD modValue.x, modValue.x, mod.x;
MUL modValue.x, modValue.x, mod.y;
MUL fragColour, fragColour, modValue.x;
MOV fragColour.a, voxValue.a;

# Colour the pixel!
MOV result.color, fragColour;

END

