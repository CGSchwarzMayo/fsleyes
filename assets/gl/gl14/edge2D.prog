# Edge detection routine for 2D textures - see also edge3D.prog.
#
# Inputs:
#
#   {{ texture  }}   - 2D texture to run edge detection on
#   {{ texCoord }}   - Texture coordinate at which to to test for edges
#   {{ offsets  }}   - Distance from this texcoord around which to sample
#                      the texture. Channels with a negative offset will
#                      not be tested.
#   {{ val      }}   - Value at the given texCoord.
#   {{ tol      }}   - Value tolerance
#
# Result:
#   {{ out_result }} - First component has 1 if the texture coordinate is
#                      on an edge, 0 otherwise.
#
#
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

{{ arb_temp('off')          }}
{{ arb_temp('back')         }}
{{ arb_temp('front')        }}
{{ arb_temp('tempCoord')    }}
{{ arb_temp('isEdgeBack')   }}
{{ arb_temp('isEdgeFront')  }}


{% set offsetmasks  = ['{1, 0, 0, 0}', '{0, 1, 0, 0}'] %}
{% set testchannels = ['x',            'y'] %}
{% for axis in range(2) %}
{% set offsetmask  = offsetmasks[ axis] %}
{% set testchannel = testchannels[axis] %}

# Test along the current axis
MOV {{ off }}, {{ offsets }};
MUL {{ off }}, {{ off     }}, {{ offsetmask }};

# Sample a value behind the coordinate
MOV {{ tempCoord }}, {{ texCoord }};
ADD {{ tempCoord }}, {{ tempCoord }}, {{ off }};
TEX {{ back      }}, {{ tempCoord }}, {{ texture }}, 2D;

# Sample a value in front of the coordinatea
MOV {{ tempCoord }}, {{ texCoord }};
SUB {{ tempCoord }}, {{ tempCoord }}, {{ off }};
TEX {{ front     }}, {{ tempCoord }}, {{ texture }}, 2D;

SUB {{ back  }}, {{ back  }}, {{ val }};
SUB {{ front }}, {{ front }}, {{ val }};
ABS {{ back  }}, {{ back  }};
ABS {{ front }}, {{ front }};

SLT {{ isEdgeBack  }}.{{ testchannel }}, {{ tol }}, {{ back  }};
SLT {{ isEdgeFront }}.{{ testchannel }}, {{ tol }}, {{ front }};

{% endfor %}

# For each of the isEdgeBack/isEdgeFront
# vectors, set all components to 1 if an
# edge was found on any component.
DP4 {{ isEdgeBack  }}.x, {{ isEdgeBack  }}.x, {{ isEdgeBack  }}.x;
DP4 {{ isEdgeFront }}.x, {{ isEdgeFront }}.x, {{ isEdgeFront }}.x;
DP4 {{ isEdgeBack  }}.y, {{ isEdgeBack  }}.y, {{ isEdgeBack  }}.y;
DP4 {{ isEdgeFront }}.y, {{ isEdgeFront }}.y, {{ isEdgeFront }}.y;

# Set out_result.i if there was an edge
# on any component of the i axis.
MAX {{ out_result }}.x, {{ isEdgeBack }}.x, {{ isEdgeFront }}.x;
MAX {{ out_result }}.y, {{ isEdgeBack }}.y, {{ isEdgeFront }}.y;

# Clamp the out_result values to 1
SGE {{ out_result }}, {{ out_result }}, 1;

# Clear if offsets[i] < 0 - this allows
# individual axes to be skipped
CMP {{ out_result }}, {{ offsets }}, 0, {{ out_result }};
