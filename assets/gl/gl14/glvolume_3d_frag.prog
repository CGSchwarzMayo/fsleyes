!!ARBfp1.0
#
# Fragment program used for rendering GLVolume instances in 3D.
#
# See the glvolume_common.prog routine for most of the logic.
#
# Input parameters:
#
#   {{ param_voxValXform }}
#   {{ param_clipping }}
#   {{ param_negCmap }}
#
#   {{ param_rayStep }} - A vector defining how far to move through the volume
#      texture space on each ray-casting iteration.
#
#   {{ param_ditherDir }} - A vector, in the same direction as the camera,
#      specifying the maximum amount to dither by.
#
#   {{ param_tex2ScreenXform }} - A transformation matrix which transforms
#      image texture coordinates into normalised device coordinates. Only
#      the row which generates the Z-coordinate should be passed in.
#
#
#   {{ param_settings }} - Contains other parametres controlling the
#      ray-casting:
#        x: How much each sampled point contributes to the final colour.
#        y: Length of the rayStep vector
#        z: How much the fragment should fade out w.r.t. its depth
#        w: Final transparency that the fragment should have
#
# Input varyings:
#   {{ varying_texCoord }}
#   {{ varying_clipTexCoord }}
#
# Input textures:
#   {{ texture_imageTexture }}
#   {{ texture_clipTexture }}
#   {{ texture_colourTexture }}
#   {{ texture_negColourTexture }}
#
#
# Constants:
#   numSteps             - Number of ray-casting iterations
#   kill_fragments_early - must be set to False
##
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

{{ arb_include('textest.prog')         }}
{{ arb_include('texture_border.prog')  }}
{{ arb_include('glvolume_common.prog') }}



TEMP  textest;
TEMP  depth;
TEMP  skipTest;

TEMP  texCoord;
TEMP  clipTexCoord;
TEMP  colour;
TEMP  tempColour;
TEMP  finalColour;
TEMP  nsamples;


# Initialise colour buffers  and
# generate a random number
# between 0 and 1 for dithering.
MOV colour,      0;
MOV finalColour, 0;
MOV nsamples,    0;
MOV depth,       0;
MOV texCoord.w,  1;

# Using skipTest as a temp var
MOV skipTest.x, fragment.position.x;
MOV skipTest.y, fragment.position.y;
MUL skipTest.x, skipTest.x, 12.9898;
MUL skipTest.y, skipTest.y, 78.233;
ADD skipTest.x, skipTest.x, skipTest.y;
SIN skipTest.x, skipTest.x;
MUL skipTest.x, skipTest.x, 43758.5453;
FRC skipTest.x, skipTest.x;

# Initialise texture coordinates
MUL skipTest,     {{ param_ditherDir      }}, skipTest.x;
ADD texCoord,     {{ varying_texCoord     }}, skipTest;
ADD clipTexCoord, {{ varying_clipTexCoord }}, skipTest;


# Start the ray-casting loop
{% for i in range(numSteps) %}


# Look up the colour to
# use for this fragment
{{
arb_call('glvolume_common.prog',
         texCoord='texCoord',
         clipTexCoord='clipTexCoord',
         clipping='{{ param_clipping }}',
         negCmap='{{ param_negCmap }}',
         voxValXform='{{ param_voxValXform }}',
         imageTexture='{{ texture_imageTexture }}',
         clipTexture='{{ texture_clipTexture }}',
         colourTexture='{{ texture_colourTexture }}',
         negColourTexture='{{ texture_negColourTexture }}',
         out_kill='skipTest',
         out_colour='colour')
}}


# Calculate the blending
# factor for this sample
MUL colour.a, nsamples.x, {{ param_settings }}.y;
SUB colour.a, 1,             colour.a;
MUL colour.a, colour.a,   {{ param_settings }}.x;

# Blend the sample into the
# accumulatedcolour, storing
# the result in a temp variable
SUB tempColour,     1,          finalColour.a;
MUL tempColour.rgb, tempColour, colour;
MUL tempColour.rgb, tempColour, colour.a;
ADD tempColour.rgb, tempColour, finalColour;

MUL tempColour.a,   tempColour.a,   colour.a;
ADD tempColour.a,   tempColour.a,   finalColour.a;


# Check whether the
# texcoords are in bounds
{{ arb_call('textest.prog', texCoord='texCoord', out_result='textest') }}
MIN skipTest.x, skipTest.x, textest.x;

# Update the sample count if
# all tests have passed so far
ADD nsamples.y,  nsamples.x, 1;
CMP nsamples.x,  skipTest.x, nsamples.x,  nsamples.y;

# Calculate the screen depth of
# the current ray position.If we
# have just taken our first sample,
# save the depth, as we will use
# it for the final fragment depth.
#
# To do this, we have to test
# whether skipTest.x > 0, and
# nsamples == 1
DP4 depth.z, {{ param_tex2ScreenXform }}, texCoord;
SLT depth.y, nsamples.x, 2;
MUL depth.y, depth.y, nsamples.x;
SUB depth.y, depth.y, 0.5;
MIN depth.y, depth.y, skipTest.x;
CMP depth.x, depth.y, depth.x, depth.z;

# Check whether final colour alpha
# is already high enough:
SLT skipTest.y, finalColour.a, 0.95;
SUB skipTest.y, skipTest.y,    0.5;
MIN skipTest.x, skipTest.x,    skipTest.y;

# Only update the accumulated colour
# buffer if:
#   - the voxel value was not nan
#   - the voxel value was not clipped
#   - the ray position was inside the volume
#   - the accumulated colour has not yet
#     reached the alpha threshold
# All of these conditions have been
# accumulated into skipTest.x
CMP finalColour, skipTest.x, finalColour, tempColour;

# Shift the ray position
ADD texCoord,     texCoord,     {{ param_rayStep }};
ADD clipTexCoord, clipTexCoord, {{ param_rayStep }};

{% endfor %}

# If no samples were
# taken, kill the fragment.
SUB nsamples.x, nsamples.x,  0.5;
KIL nsamples.x;

MOV finalColour.a, {{ param_settings }}.w;
MOV result.color,     finalColour;
MOV result.depth,     depth.x;

END
