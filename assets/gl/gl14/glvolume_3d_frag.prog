!!ARBfp1.0
OPTION ARB_precision_hint_nicest;
#
# Fragment program used for rendering GLVolume instances in 3D.
#
# See the glvolume_common.prog routine for most of the logic.
#
# Input parameters:
#
#   {{ param_voxValXform }}
#   {{ param_clipping }}
#   {{ param_negCmap }}
#
#   {{ param_screenSize }}
#
#   {{ param_rayStep }} - A vector defining how far to move through the volume
#      texture space on each ray-casting iteration.
#
#      Component w is the starting iteration
#
#   {{ param_ditherDir }} - A vector, in the same direction as the camera,
#      specifying the maximum amount to dither by.
#
#   {{ param_tex2ScreenXform }} - A transformation matrix which transforms
#      image texture coordinates into normalised device coordinates. Only
#      the row which generates the Z-coordinate should be passed in.
#
#
#   {{ param_settings }} - Contains other parametres controlling the
#      ray-casting:
#        x: How much each sampled point contributes to the final colour.
#        y: Length of the rayStep vector
#        z: How much the fragment should fade out w.r.t. its depth
#        w: Final transparency that the fragment should have
#
# Input varyings:
#   {{ varying_texCoord }}
#   {{ varying_clipTexCoord }}
#
# Input textures:
#   {{ texture_startingTexture }}
#   {{ texture_imageTexture }}
#   {{ texture_clipTexture }}
#   {{ texture_colourTexture }}
#   {{ texture_negColourTexture }}
#
#
# Constants:
#   numSteps             - Number of ray-casting iterations
#   kill_fragments_early - must be set to False
##
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

{{ arb_include('textest.prog')         }}
{{ arb_include('texture_border.prog')  }}
{{ arb_include('glvolume_common.prog') }}


TEMP  depth;
TEMP  skipTest;
TEMP  startingColour;
TEMP  tempVar;

TEMP  texCoord;
TEMP  clipTexCoord;
TEMP  colour;
TEMP  tempColour;
TEMP  finalColour;


# Initialise texture coordinates.
MAD texCoord.xyz,     {{ param_rayStep }}.w, {{ param_rayStep }}, {{ varying_texCoord     }};
MAD clipTexCoord.xyz, {{ param_rayStep }}.w, {{ param_rayStep }}, {{ varying_clipTexCoord }};


# Generate a random number
# between 0 and 1 for dithering.
MOV tempVar.x, fragment.position.x;
MOV tempVar.y, fragment.position.y;
MUL tempVar.x, tempVar.x, 12.9898;
MUL tempVar.y, tempVar.y, 78.233;
ADD tempVar.x, tempVar.x, tempVar.y;
SIN tempVar.x, tempVar.x;
MUL tempVar.x, tempVar.x, 43758.5453;
FRC tempVar.x, tempVar.x;


# Add dither to the starting location
MUL tempVar,       {{ param_ditherDir }}, tempVar.x;
ADD texCoord.xyz,     texCoord,           tempVar;
ADD clipTexCoord.xyz, clipTexCoord,       tempVar;


# Retrieve the starting colour
MUL tempVar.xy,     fragment.position, {{ param_screenSize        }};
TEX startingColour, tempVar,           {{ texture_startingTexture }}, 2D;


MOV depth,       0;
MOV texCoord.w,  1;
MOV skipTest,    1;
MOV finalColour, startingColour;


# Start the ray-casting loop
{% for i in range(numSteps) %}


# Look up the colour to
# use for this fragment
{{
arb_call('glvolume_common.prog',
         texCoord='texCoord',
         clipTexCoord='clipTexCoord',
         clipping='{{ param_clipping }}',
         negCmap='{{ param_negCmap }}',
         voxValXform='{{ param_voxValXform }}',
         imageTexture='{{ texture_imageTexture }}',
         clipTexture='{{ texture_clipTexture }}',
         colourTexture='{{ texture_colourTexture }}',
         negColourTexture='{{ texture_negColourTexture }}',
         out_kill='skipTest',
         out_colour='colour')
}}



# Check whether the
# texcoords are in bounds
{{ arb_call('textest.prog', texCoord='texCoord', out_result='tempVar') }}
MIN skipTest.x, skipTest.x, tempVar.x;



# Check whether the accumulated
# colour alpha is already high enough
SLT tempVar.x,  finalColour.a, 0.95;
SUB tempVar.x,  tempVar.x,     0.5;
MIN skipTest.x, skipTest.x,    tempVar.x;



# Blend the sample into the
# accumulated colour, storing
# the result in tempColour

# tempVar.x contains (1 - finalColour.a) * blendFactor
SUB tempVar.x, 1,               finalColour.a;
MUL tempVar.x, tempVar.x,    {{ param_settings }}.x;

MAD tempColour.rgb, tempVar.x,   colour, finalColour;
ADD tempColour.a,   tempVar.x,           finalColour.a;


# Only update the accumulated colour
# buffer if:
#   - the voxel value was not nan
#   - the voxel value was not clipped
#   - the ray position was inside the volume
#   - the accumulated colour has not yet
#     reached the alpha threshold
# All of these conditions have been
# accumulated into skipTest.x
CMP finalColour, skipTest.x, finalColour, tempColour;



# Shift the ray position
ADD texCoord.xyz,     texCoord,     {{ param_rayStep }};
ADD clipTexCoord.xyz, clipTexCoord, {{ param_rayStep }};



{% endfor %}



# If startingColour.a == 0 and
#    finalColour.a    == 0,
# kill the fragment.

ADD tempVar.x, startingColour.a, finalColour.a;
MUL tempVar.x, tempVar.x, -1;
CMP tempVar.x, tempVar.x,  1, -1;
KIL tempVar.x;


MOV result.color, finalColour;


END
