!!ARBfp1.0
#
# Fragment program used for rendering GLVolume instances in 3D.
#
# See the glvolume_common.prog routine for most of the logic.
#
# Input parameters:
#
#   {{ param_voxValXform }}
#   {{ param_clipping }}
#   {{ param_negCmap }}
#
#   {{ param_rayStep }} - A vector defining how far to move through the volume
#      texture space on each ray-casting iteration.
#
#   {{ param_ditherDir }} - A vector, in the same direction as the camera,
#      specifying the maximum amount to dither by.
#
#   {{ param_tex2ScreenXform }} - A transformation matrix which transforms
#      image texture coordinates into normalised device coordinates.
#
#   {{ param_settings }} - Contains other parametres controlling the
#      ray-casting:
#        x: How much each sampled point contributes to the final colour.
#        y: Length of the rayStep vector
#        z: How much the fragment should fade out w.r.t. its depth
#        w: Final transparency that the fragment should have
#
# Input varyings:
#   {{ varying_texCoord }}
#   {{ varying_clipTexCoord }}
#
# Input textures:
#   {{ texture_imageTexture }}
#   {{ texture_clipTexture }}
#   {{ texture_colourTexture }}
#   {{ texture_negColourTexture }}
#
#
# Constants:
#   numSteps             - Number of ray-casting iterations
#   kill_fragments_early - must be set to False
##
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

{{ arb_include('textest.prog')         }}
{{ arb_include('texture_border.prog')  }}
{{ arb_include('glvolume_common.prog') }}



TEMP  dither;
TEMP  textest;
TEMP  depth;
TEMP  lastSampledTexCoord;

TEMP  texCoord;
TEMP  clipTexCoord;
TEMP  colour;
TEMP  tempColour;
TEMP  finalColour;
TEMP  nsamples;

TEMP  skipTest;

PARAM clipping           = {{ param_clipping         }};
PARAM negCmap            = {{ param_negCmap          }};
PARAM voxValXform        = {{ param_voxValXform      }};
PARAM rayStep            = {{ param_rayStep          }};
PARAM ditherDir          = {{ param_ditherDir        }};
PARAM tex2ScreenXform[4] = {{ param4_tex2ScreenXform }};


# Initialise colour buffers  and
# generate a random number
# between 0 and 1 for dithering.
MOV colour,      0;
MOV finalColour, 0;
MOV nsamples,    0;
MOV dither.x, fragment.position.x;
MOV dither.y, fragment.position.y;
MUL dither.x, dither.x, 12.9898;
MUL dither.y, dither.y, 78.233;
ADD dither.x, dither.x, dither.y;
SIN dither.x, dither.x;
MUL dither.x, dither.x, 43758.5453;
FRC dither.x, dither.x;

# Initialise texture coordinates
MUL dither, ditherDir, dither.x;
ADD texCoord,     {{ varying_texCoord }},     dither;
ADD clipTexCoord, {{ varying_clipTexCoord }}, dither;
MOV lastSampledTexCoord, texCoord;



# Start the ray-casting loop
{% for i in range(numSteps) %}


# Look up the colour to
# use for this fragment
{{
arb_call('glvolume_common.prog',
         texCoord='texCoord',
         clipTexCoord='clipTexCoord',
         clipping='{{ param_clipping }}',
         negCmap='{{ param_negCmap }}',
         voxValXform='{{ param_voxValXform }}',
         imageTexture='{{ texture_imageTexture }}',
         clipTexture='{{ texture_clipTexture }}',
         colourTexture='{{ texture_colourTexture }}',
         negColourTexture='{{ texture_negColourTexture }}',
         out_kill='skipTest',
         out_colour='colour')
}}


# Calculate the blending
# factor for this sample
MUL colour.a, nsamples.x, {{ param_settings }}.y;
SUB colour.a, 1,             colour.a;
MUL colour.a, colour.a,   {{ param_settings }}.x;

# Blend the sample into the
# accumulatedcolour, storing
# the result in a temp variable
SUB tempColour,     1,          finalColour.a;
MUL tempColour.rgb, tempColour, colour;
MUL tempColour.rgb, tempColour, colour.a;
ADD tempColour.rgb, tempColour, finalColour;

MUL tempColour.a,   tempColour.a,   colour.a;
ADD tempColour.a,   tempColour.a,   finalColour.a;


# Check whether the
# texcoords are in bounds
{{ arb_call('textest.prog', texCoord='texCoord', out_result='textest') }}
MIN skipTest.x, skipTest.x, textest.x;

# Update the sample count if
# all tests have passed so far
ADD nsamples.y,  nsamples.x, 1;
CMP nsamples.x,  skipTest.x, nsamples.x,  nsamples.y;


# Check whether final colour alpha
# is already high enough:
SLT textest.y,  finalColour.a, 0.95;
SUB textest.y,  textest.y,     0.5;
MIN skipTest.x, skipTest.x, textest.y;

# Only update the accumulated colour
# buffer if:
#   - the voxel value was not nan
#   - the voxel value was not clipped
#   - the ray position was inside the volume
#   - the accumulated colour has not yet
#     reached the alpha threshold
# All of these conditions have been
# accumulated into skipTest.x
CMP finalColour, skipTest.x, finalColour, tempColour;

# Shift the ray position
ADD texCoord,     texCoord,     rayStep;
ADD clipTexCoord, clipTexCoord, rayStep;

{% endfor %}

# If no samples were
# taken, kill the fragment.
SUB nsamples.x, nsamples.x,  0.5;
KIL nsamples.x;

MOV finalColour.a, {{ param_settings }}.w;
MOV result.color, finalColour;

END
