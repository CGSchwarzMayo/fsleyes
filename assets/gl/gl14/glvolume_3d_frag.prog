!!ARBfp1.0
#
# Fragment program used for rendering GLVolume instances in 3D.
#
# See the glvolume_common.prog routine for most of the logic.
#
# Input parameters:
#
#   {{ param_voxValXform }}
#   {{ param_clipping }}
#   {{ param_negCmap }}
#
#   {{ param_rayStep }} - A vector defining how far to move through the volume
#      texture space on each ray-casting iteration.
#
#   {{ param_ditherDir }} - A vector, in the same direction as the camera,
#      specifying the maximum amount to dither by.
#
#   {{ param_tex2ScreenXform }} - A transformation matrix which transforms
#      image texture coordinates into normalised device coordinates.
#
# Input varyings:
#   {{ varying_texCoord }}
#   {{ varying_clipTexCoord }}
#
# Input textures:
#   {{ texture_imageTexture }}
#   {{ texture_clipTexture }}
#   {{ texture_colourTexture }}
#   {{ texture_negColourTexture }}
#
#
# Constants:
#   numSteps             - Number of ray-casting iterations
#   kill_fragments_early - must be set to False
##
# Author: Paul McCarthy <pauldmccarthy@gmail.com>
#

{{ arb_include('textest.prog')         }}
{{ arb_include('texture_border.prog')  }}
{{ arb_include('glvolume_common.prog') }}



TEMP  dither;
TEMP  textest;
TEMP  depth;
TEMP  lastSampledTexCoord;

TEMP  texCoord;
TEMP  clipTexCoord;
TEMP  colour;
TEMP  tempColour;
TEMP  finalColour;

TEMP  skipTest;

PARAM clipping           = {{ param_clipping         }};
PARAM negCmap            = {{ param_negCmap          }};
PARAM voxValXform        = {{ param_voxValXform      }};
PARAM rayStep            = {{ param_rayStep          }};
PARAM ditherDir          = {{ param_ditherDir        }};
PARAM tex2ScreenXform[4] = {{ param4_tex2ScreenXform }};


# Initialise colour buffers  and
# generate a random number
# between 0 and 1 for dithering.
MOV colour,      0;
MOV finalColour, 0;
MOV dither.x, fragment.position.x;
MOV dither.y, fragment.position.y;
MUL dither.x, dither.x, 12.9898;
MUL dither.y, dither.y, 78.233;
ADD dither.x, dither.x, dither.y;
SIN dither.x, dither.x;
MUL dither.x, dither.x, 43758.5453;
FRC dither.x, dither.x;

# Initialise texture coordinates
MUL dither, ditherDir, dither.x;
ADD texCoord,     {{ varying_texCoord }},     dither;
ADD clipTexCoord, {{ varying_clipTexCoord }}, dither;
MOV lastSampledTexCoord, texCoord;



# Start the ray-casting loop
{% for i in range(numSteps) %}


# Look up the colour to
# use for this fragment
{{
arb_call('glvolume_common.prog',
         texCoord='texCoord',
         clipTexCoord='clipTexCoord',
         clipping='{{ param_clipping }}',
         negCmap='{{ param_negCmap }}',
         voxValXform='{{ param_voxValXform }}',
         imageTexture='{{ texture_imageTexture }}',
         clipTexture='{{ texture_clipTexture }}',
         colourTexture='{{ texture_colourTexture }}',
         negColourTexture='{{ texture_negColourTexture }}',
         out_kill='skipTest',
         out_colour='colour')
}}


# Mix this colour with the accumulated
# colour into a temp variable.
LRP tempColour.rgb, finalColour.a, finalColour.rgbb, colour.rgbb;
ADD tempColour.a, finalColour.a, colour.a;


# Check whether the
# texcoords are in bounds
{{ arb_call('textest.prog', texCoord='texCoord', out_result='textest') }}
MIN skipTest.x, skipTest.x, textest.x;


# Check whether final colour alpha
# is already high enough:
SLT textest.y,  finalColour.a, 0.95;
SUB textest.y,  textest.y,     0.5;
MIN skipTest.x, skipTest.x, textest.y;

# Only update the accumulated colour
# buffer if:
#   - if the voxel value was not nan
#   - the voxel value was not clipped
#   - the ray position was inside the volume
#   - the accumulated colour has not yet
#     reached the alpha threshold
# All of these conditions have been
# accumulated into skipTest.x
#

CMP finalColour, skipTest.x, finalColour, tempColour;

# Shift the ray position
ADD texCoord,     texCoord,     rayStep;
ADD clipTexCoord, clipTexCoord, rayStep;


{% endfor %}


MOV result.color, finalColour;

END
